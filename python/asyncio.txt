# Types
# Awaitable: any object that can be awaited
# - Coroutine function: `async def ..` function
# - Coroutine object: object returned by calling async def
# - Task: used to schedule coroutines concurrently
# - Future: operation like asyncio.gather that represents future results of op


# Type
async def fn1(n) -> list[int]: // returns list when awaited or executed with asyncio.run
  ints = []
  for i in range(n):
    print(f'Fn1 {i}/{n}')
    await asyncio.sleep(1)  # must be awaited!
    ints.append(i)
  return ints

f: Awaitable[list[in]] = fn1(3)  // instance is Coroutine or Awaitable[T] or Coroutine[T1, T2, T2]
f // coroutine type
type(f) // collections.abc.Coroutine
isinstance(f, collections.abc.Coroutine)  // true
isinstance(f, collections.abc.Awaitable)  // true


# Gather

async def fn1_chained():
  start_time = time.time()
  ints1 = await fn1(0)
  # waits 3s until fn1 finished
  ints2 = await fn1(3)
  # waits 3s until fn1 finished
  print('Took %ds' % (time.time() - start_time))
  # 6s
  return [ints1, ints2]

async def fn1_gathered():
  start_time = time.time()
  # Executed in parallel; preserves order
  result = await asyncio.gather(fn1(0), fn1(3))
  print('Took %ds' % (time.time() - start_time))
  # Takes 3s
  return result


# Async for

async def fn1(start) -> collections.abc.Iterator[int]:
  for i in range(start, start + 3):
    print(f'Fn1-{start} {i}')
    await asyncio.sleep(1)
    yield i


async def fn():
  values = []
  # fn1() must be an asynchronous generator; range(3) does not work since sychronous
  # for value in await fn1() does not work
  async for value in fn1(0):
    values.append(value)
  return values


# Threads
* to parallel blocking synchronous function
* asyncio.to_thread executes function in thread
* threads can access context vars


def read_file(filename):
  time.sleep(1)
  return filename

async def read_files():
  start_time = time.time()
  values = await asyncio.gather(
      asyncio.to_thread(read_file, 'file1'),
      asyncio.to_thread(read_file, 'file2'),
      asyncio.to_thread(read_file, 'file3')
  )
  print('Tool %ds' % (time.time() - start_time))
  # Takes 1s
  return values



# ContextVar
* Global whose value depends on the context of coroutine

foo = contextvars.ContextVar('foo')


async def print_context_var(uid):
  print(f'Value uid={uid}: {foo.get()}')


async def set_context(uid):
  foo.set(-uid)
  await asyncio.sleep(uid)
  await print_context_var(uid)


async def contextvar_example():
  start = time.time()
  await asyncio.gather(set_context(1), set_context(2), set_context(3))
  print('Took %ds' % (time.time() - start))


asyncio.run(contextvar_example())
