import re

m = re.search(pattern, string, flags)
m is None // no match

re.match(pattern, string, flags)
  * must match at beginning
  * 'abc' does not match 'xxx abc xxx'
  * 'xxx' does not match 'xxx abc xxx'
re.search(pattern, string, flags)
  * pattern must partially match anywhere
  * 'abc' matches 'xxx abc xxx'
    -> '.*abc' not needed!
  * same as re.search(^pattern, ...)
re.fullmatch(pattern, string, flags
  * pattern must match entire string
  * ^.*XXX.*$ unncessary
for m in re.finditer(pattern, string)  // like search, but iter of all hits
re.findall(pattern, string) // all matches as str in array (see below)
len(re.findall(...)) // count

# re.sub
re.sub(p, r, s) // subst ALL p in s by r and returns substituted string
re.subn() // like sub, but return number of replacements
re.sub(r'(.*\.)(solver)$', r'\g<1>\g<2>_cls', idx) // reference groups
  * use \g<1> instead of \1 since '\123' does not replace by (group1)23!
// Backslash must be escaped in the replacement, not with re.escape!
re.sub(regex, r'\g<1>' + repl.replace('\\', '\\\\') + r'\g<2>', text)

# re.split
// Split and do return delimiter
re.split(r'[xy]', '123x456y789') # ['123', '456', '789']

# Split and return delimiter
re.split(r'([xy])', '123x456y789') # ['123', 'x', '456', 'y', '789']


# Groups
m.groups() // returns all groups as tuple
  * length == number of (...) parts in re
m.group() // everything
m.group(0)  // everything
m.group(1)  // group 1
m.start()
m.end()

## Groups dict
m = re.search(r'^(?P<start>\d+)(-(?P<stop>\d+))?$', sel)
d = m.groupdict()
d['start'], d['stop']
  * d['stop'] == None if missing


# Special characters
\n: newline linux
\r\n: newline windows
\t: horizontal tab
\v: vertical tab (historic)
\f: new page (historic)
\s: any whitespace [ \n\r\t\v\f]
\S: opposite of \s [^\s]
\w: alphanumeric [a-zA-Z0-9_].
\W: opposite of \w
\b: Word boundary (end/beginning of string; before/after whitespace)
\A: matches beginning of string (^ is beginning of line with re.MULTILINE)
\Z: matches end of string ($ is end of line with re.MULTILINE)


# Raw string (r'', r"", r""" """)
* \ has no effect
print(r'\n') == '\n'
print(r'\\n') == '\\n'
display(r'\n') == '\\n'   // display (__repr__) escapes backslashes!

re.fullmatch(r'\d+\\\d+', r'123\456')  # matches
re.fullmatch('\d+\\\d+', r'123\456')  # does not match (re is not r)
re.fullmatch('\d+\\\\\d+', r'123\456')  # matches
re.fullmatch('\d+ \d+', '123 456')  # r not required for \d, \s, or \w


# Triple quote
* Allows line breaks (newline \n)
* Newline can be escaped unless in raw string
print('''\
a''') == 'a'

print(r'''\
a''') == '\
a'
# Flags
r'(?ism)...' // to express options in regex
re.I | re.IGNORECASE // insensitive
re.S | re.DOTALL // . matches also \n (it matches everything but . by default)
re.M | re.MULTILINE // ^ matches also beginning of a line, not only the entire string
re.X | re.VERBOSE // ignores any whitespaces (' ' or \n) except '[ ]' and '\ ';
                  // # must be escaped!

## Verbose
re.compile(r'''
 \d +  # digests
 [ ] \   # two spaces
   ''', re.X) == re.compile(r'\d+[ ] ')

re.compile(r'''
^Line1[^\n]+$\n
^Line1[^\n]+$\n
''', re.MULTILINE | re.VERBOSE
) matches 'Line1\nLine2'
* $ marks the end of the line
* \n still requires after \n, which is the actual newline character


# Capture groups
(?P<name>regex): named capture group (for m.groupdict())
(?:regex): group that is ignored (not in m.groups() / m.groupdict())
(?ismx)regex: set flags (re.I, re.D, re.M, re.V) for the entire regex
(?ismx:regex): set flags for single group; won't be captured with :
(?P<name>(?ismx:regex)): combined flags with other options

## ?P<name> Named groups
m = re.fullmatch(r'(--)?(?P<name>[^=]+)(=(?P<value>[^=]+))?', flag_string)
m.group('name')
m.group('value')  // None if missing
m.groups()  // returns tuple of values
.m.groupdict() returns dict mapping group names to group values
.m.group('name')
# Positive/negative lookahead/lookbehind

## Positive lookahead
(?=regex1)regex2: Check that regex1 is a prefix of regex2 by iterating forward from the current position without consuming characters
regex1(?=regex2): Check that regex1 is followed by regex2 by iterating forward
(?!regex)regex2: Check that regex1 is not a prefix of regex2
regex1(?!regex2): Check that regex1 is not followed by regex2

## Positive/negative lookbehind
* Must be fixed-length (not `?<.*)

(?<regex1)regex2: Check that regex2 is preceded by regex1 by iterating backward from the current position without consuming characters
regex1(?<regex2): Check that regex2 is a suffix of regex1 by iterating backward
(?<!regex1)regex2: Check that regex2 it not preceded by regex1
regex1(?<!regex2): Check that regex2 is not a suffix of regex1

## Examples

// Match lines of digests that start with 123
re.findall(
    r'^(?=123)\d+$',
    """
234
1234
12245
12345
""",
    re.MULTILINE,
)  # ['1234', '12345']

// Match lines of digests that do not start with 123
re.findall(
    r'^(?!123)\d+$',
    """
234
1234
12245
12345
""",
    re.MULTILINE,
)  # ['234', '12245']

// Match lines of digests that end with 789
re.findall(
    r'^\d+(?<=789)$',
    """
234789
1234
12789
12779
""",
    re.MULTILINE,
)  # ['234789', '12789']

// Match lines of digests that to not end with 789
re.findall(
    r'^\d+(?<!789)$',
    """
234789
1234
12789
12779
""",
    re.MULTILINE,
)  # ['1234', '12779']

// Match digests that are followed 789
re.findall(
    r'^\d+(?=789)',
    """
234789
1234
12789
12779
""",
    re.MULTILINE,
)  # ['234', '234']


// Match lines of digests that contain 123
re.findall(
    r'^(?=.*123)\d+$',
    """
12345
01234
0124
0123
""",
    re.MULTILINE,
)  # ['12345', '01234' '0123']


// Match lines of digests that do not contain 123
re.findall(
    r'^(?!.*123)\d+$',
    """
12345
01234
0124
0123
""",
    re.MULTILINE,
)  # ['0124']

// Replace characters that are preceeded by digests by '|CHARS (not the digests)
re.sub(r'(?<=\d)[a-z]+', '|CHARS', '123abc')  == '123|CHARS'
